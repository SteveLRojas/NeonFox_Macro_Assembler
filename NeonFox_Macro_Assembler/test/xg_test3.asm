;                     /\         /\__
;                   // \       (  0 )_____/\            __
;                  // \ \     (vv          o|          /^v\
;                //    \ \   (vvvv  ___-----^        /^^/\vv\
;              //  /     \ \ |vvvvv/               /^^/    \v\
;             //  /       (\\/vvvv/              /^^/       \v\
;            //  /  /  \ (  /vvvv/              /^^/---(     \v\
;           //  /  /    \( /vvvv/----(O        /^^/           \v\
;          //  /  /  \  (/vvvv/               /^^/             \v|
;        //  /  /    \( vvvv/                /^^/               ||
;       //  /  /    (  vvvv/                 |^^|              //
;      //  / /    (  |vvvv|                  /^^/            //
;     //  / /   (    \vvvvv\          )-----/^^/           //
;    // / / (          \vvvvv\            /^^^/          //
;   /// /(               \vvvvv\        /^^^^/          //
;  ///(              )-----\vvvvv\    /^^^^/-----(      \\
; //(                        \vvvvv\/^^^^/               \\
;/(                            \vvvv^^^/                 //
;                                \vv^/         /        //
;                                             /<______//
;                                            <<<------/
;                                             \<
;                                              \
;**************************************************
;* XG_TEST3.ASM               SOURCE FILE         *
;* Copyright (C) 2022 Esteban Looser-Rojas.       *
;* Contains test program for the NeonFox          *
;* processor validation platform.                 *
;**************************************************

INCLUDE "NEONFOX.INC"

MACRO	SDADDR ADDRESS	;SHORT DATA ADDRESS
	LIM H, AUX1, `LH ADDRESS
	LIM L, AUX1, `LL ADDRESS
	MOVE W, AUX1, DAL
ENDMACRO SDADDR

MACRO LDADDR ADDRESS	;LONG DATA ADDRESS
	LIM H, AUX1, `HH ADDRESS
	LIM L, AUX1, `HL ADDRESS
	LIM H, AUX2, `LH ADDRESS
	LIM L, AUX2, `LL ADDRESS
	MOVE W, AUX1, DAH
	MOVE W, AUX2, DAL
ENDMACRO LDADDR

MACRO IADDR ADDRESS	;IO ADDRESS
	LIM H, AUX1, `LH ADDRESS
	LIM L, AUX1, `LL ADDRESS
	MOVE W, AUX1, IAL
ENDMACRO IADDR

MACRO LPLOAD ADDRESS, TARGET	;GET DATA FROM LONG POINTER
	LIM H, AUX1, `HH ADDRESS
	LIM L, AUX1, `HL ADDRESS
	LIM H, AUX2, `LH ADDRESS
	LIM L, AUX2, `LL ADDRESS
	MOVE W, AUX1, DAH
	MOVE W, AUX2, DAL
	MOVE W, DD, TARGET
ENDMACRO LPLOAD

MACRO SPLOAD ADDRESS, TARGET	;GET DATA FROM SHORT POINTER
	LIM H, AUX1, `LH ADDRESS
	LIM L, AUX1, `LL ADDRESS
	MOVE W, AUX1, DAL
	MOVE W, DD, TARGET
ENDMACRO SPLOAD

MACRO IPLOAD ADDRESS, TARGET	;GET DATA FROM IO POINTER
	LIM H, AUX1, `LH ADDRESS
	LIM L, AUX1, `LL ADDRESS
	MOVE W, AUX1, IAL
	MOVE W, ID, TERGET
ENDMACRO IPLOAD

;VARIABLES
;$0000 TO $0FFF IS RESERVED FOR SYSTEM ROM SHADOW

CHR_PATTERN			EQU $1000	;GENERATED CHARACTER PATTERNS
CHR_PATTERN_END		EQU $1FFF

CHR_COLOR			EQU $2000	;PALETTE INDEX USED FOR CHARACTERS
CHR_BG_COLOR		EQU $2001	;BACKGROUND PALETTE INDEX USED FOR CHARACTERS
DRAW_TEXT_OFFSET	EQU $2002	;WHERE ON THE SCREEN TO PLACE TEXT (ATTRIBUTE INDEX)
DRAW_TEXT_PALETTE	EQU $2003	;WHICH PALETTE TO USE FOR TEXT

TEXT_BUFFER			EQU $2004	;TEMPORARY STRING STORAGE
TEXT_BUFFER_END 	EQU $2103

INDICATOR_VALUE		EQU $2104	;COPY OF VALUE SHOWN IN HEX DISPLAY

SAVE_AUX0			EQU $2105
SAVE_AUX1			EQU $2106
SAVE_AUX2			EQU $2107

SAVE_R0			EQU $2108
SAVE_R1			EQU $2109
SAVE_R2			EQU $210A
SAVE_R3			EQU $210B
SAVE_R4			EQU $210C
SAVE_R5			EQU $210D
SAVE_R6			EQU $210E
SAVE_R7			EQU $210F
SAVE_R8			EQU $2110
SAVE_R9			EQU $2111
SAVE_R10			EQU $2112
SAVE_R11			EQU $2113

SAVE_DAL			EQU $2114
SAVE_DAH			EQU $2115
SAVE_IAL			EQU $2116
SAVE_CAL			EQU $2117
SAVE_CAH			EQU $2118
SAVE_RAL			EQU $2119
SAVE_RAH			EQU $211A
SAVE_STATUS			EQU $211B

H_POSITION		EQU $211C
V_POSITION		EQU $211D
H_VELOCITY			EQU $211E
V_VELOCITY			EQU $211F
H_ACCELERATION		EQU $2120
V_ACCELERATION		EQU $2121

ATTRIBUTE_BUF		EQU $4000	;COPY OF ATTRIBUTE TABLE
ATTRIBUTE_BUF_END	EQU $8AFF

;$020000 TO $02FFFF IS RESERVED FOR GRAPHICS HARDWARE (PATTERN TABLE)
;$030000 TO $034AFF IS RESERVED FOR GRAPHICS HARDWARE (ATTRIBUTE TABLE)


	ORG 0
	BRA INT_RESET
	NOP
	BRA INT_HSYNC	;HSYNC
	NOP
	BRA INT_VSYNC ;VSYNC
	NOP
	RET	;UART RX
	NOP
	RET	;UART TX
	NOP
	RET	;KB RX
	NOP
	RET	;TIMER
	NOP
	RET	;INT7
	NOP
	RET	;INT8
	NOP
	RET ;INT9
	NOP
	RET	;INT10
	NOP
	RET	;INT11
	NOP
	RET	;INT12
	NOP
	RET	;INT13
	NOP
	RET	;INT14
	NOP
	RET ;INT15
	NOP

INT_HSYNC
	MOVE W, STATUS, R12
	MOVE W, IAL, R15

	LIM H, AUX3, `LH INTERRUPT_STATUS
	LIM L, AUX3, `LL INTERRUPT_STATUS
	MOVE W, AUX3, IAL
	LIM W, AUX3, $02
	NOT W, AUX3, ID

	MOVE W, R15, IAL
	RET
	MOVE W, R12, STATUS

INT_VSYNC
	;SAVE ALL REGISTERS
	MOVE W, STATUS, R12
	MOVE W, AUX0, AUX3
	MOVE W, DAL, R13
	MOVE W, DAH, R14
	MOVE W, IAL, R15

	LIM H, AUX0, `LH SAVE_AUX0
	LIM L, AUX0, `LL SAVE_AUX0
	MOVE W, ZERO, DAH
	MOVE W, AUX0, DAL
	LIM W, AUX0, $01
	MOVE W, AUX3, DD
	ADD W, DAL, DAL
	MOVE W, AUX1, DD
	ADD W, DAL, DAL
	MOVE W, AUX2, DD

	ADD W, DAL, DAL
	MOVE W, R0, DD
	ADD W, DAL, DAL
	MOVE W, R1, DD
	ADD W, DAL, DAL
	MOVE W, R2, DD
	ADD W, DAL, DAL
	MOVE W, R3, DD
	ADD W, DAL, DAL
	MOVE W, R4, DD
	ADD W, DAL, DAL
	MOVE W, R5, DD
	ADD W, DAL, DAL
	MOVE W, R6, DD
	ADD W, DAL, DAL
	MOVE W, R7, DD
	ADD W, DAL, DAL
	MOVE W, R8, DD
	ADD W, DAL, DAL
	MOVE W, R9, DD
	ADD W, DAL, DAL
	MOVE W, R10, DD
	ADD W, DAL, DAL
	MOVE W, R11, DD

	ADD W, DAL, DAL
	MOVE W, R13, DD
	ADD W, DAL, DAL
	MOVE W, R14, DD
	ADD W, DAL, DAL
	MOVE W, R15, DD
	ADD W, DAL, DAL
	MOVE W, CAL, DD
	ADD W, DAL, DAL
	MOVE W, CAH, DD
	ADD W, DAL, DAL
	MOVE W, RAL, DD
	ADD W, DAL, DAL
	MOVE W, RAH, DD
	ADD W, DAL, DAL
	MOVE W, R12, DD

	;DO THE THING
	LIM H, AUX1, `HH HEX_INC
	LIM L, AUX1, `HL HEX_INC
	LIM H, AUX0, `LH HEX_INC
	LIM L, AUX0, `LL HEX_INC
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH H_POSITION
	LIM L, AUX0, `LL H_POSITION
	MOVE W, AUX0, DAL
	MOVE W, ZERO, DAH

	LIM H, AUX0, `LH 640
	LIM L, AUX0, `LL 640
	MOVE W, DD, AUX1		;GET CURRENT POSITION
	BRNP IV_H_VELOCITY		;IF CURRENT POSITION IS NOT POSITIVE
	SUB W, AUX1, AUX0
	BRN IV_H_POSITION		;IF CURRENT POSITION IS LESS THAN 640

IV_H_VELOCITY
	LIM H, AUX0, `LH H_VELOCITY
	LIM L, AUX0, `LL H_VELOCITY
	MOVE W, AUX0, DAL
	MOVE W, DD, AUX0
	SUB W, ZERO, DD

IV_H_POSITION
	LIM H, AUX0, `LH H_VELOCITY
	LIM L, AUX0, `LL H_VELOCITY
	MOVE W, AUX0, DAL
	MOVE W, DD, AUX0	;GET CURRENT VELOCITY

	ADD W, AUX1, AUX1	;ADD VELOCITY TO POSITION
	LIM H, AUX0, `LH H_POSITION
	LIM L, AUX0, `LL H_POSITION 
	MOVE W, AUX0, DAL
	MOVE W, AUX1, DD	;UPDATE POSITION VARIABLE

	LIM H, AUX0, `LH XGRI_HSCROLL
	LIM L, AUX0, `LL XGRI_HSCROLL 
	MOVE W, AUX0, IAL
	MOVE W, AUX1, ID	;UPDATE POSITION IN XGRI

	;RESTORE ALL REGISTERS
	LIM H, AUX0, `LH SAVE_AUX0
	LIM L, AUX0, `LL SAVE_AUX0
	MOVE W, ZERO, DAH
	MOVE W, AUX0, DAL
	LIM W, AUX0, $01
	MOVE W, DD, AUX3
	ADD W, DAL, DAL
	MOVE W, DD, AUX1
	ADD W, DAL, DAL
	MOVE W, DD, AUX2

	ADD W, DAL, DAL
	MOVE W, DD, R0
	ADD W, DAL, DAL
	MOVE W, DD, R1
	ADD W, DAL, DAL
	MOVE W, DD, R2
	ADD W, DAL, DAL
	MOVE W, DD, R3
	ADD W, DAL, DAL
	MOVE W, DD, R4
	ADD W, DAL, DAL
	MOVE W, DD, R5
	ADD W, DAL, DAL
	MOVE W, DD, R6
	ADD W, DAL, DAL
	MOVE W, DD, R7
	ADD W, DAL, DAL
	MOVE W, DD, R8
	ADD W, DAL, DAL
	MOVE W, DD, R9
	ADD W, DAL, DAL
	MOVE W, DD, R10
	ADD W, DAL, DAL
	MOVE W, DD, R11

	ADD W, DAL, DAL
	MOVE W, DD, R13
	ADD W, DAL, DAL
	MOVE W, DD, R14
	ADD W, DAL, DAL
	MOVE W, DD, R15
	ADD W, DAL, DAL
	MOVE W, DD, CAL
	ADD W, DAL, DAL
	MOVE W, DD, CAH
	ADD W, DAL, DAL
	MOVE W, DD, RAL
	ADD W, DAL, DAL
	MOVE W, DD, RAH
	ADD W, DAL, DAL
	MOVE W, DD, R12
	ADD W, DAL, DAL

	MOVE W, R13, DAL
	MOVE W, R14, DAH
	MOVE W, AUX3, AUX0
	LIM H, AUX3, `LH INTERRUPT_STATUS
	LIM L, AUX3, `LL INTERRUPT_STATUS
	MOVE W, AUX3, IAL
	LIM W, AUX3, $04
	NOT W, AUX3, ID
	MOVE W, R15, IAL
	RET
	MOVE W, R12, STATUS


INT_RESET
;SET ALL REGISTERS TO ZERO
	LIM W, AUX0, $00
	LIM W, AUX1, $00
	MOVE W, AUX0, AUX2
	MOVE W, AUX1, AUX3
	MOVE W, AUX0, R0
	MOVE W, AUX0, R1
	MOVE W, AUX0, R2
	MOVE W, AUX0, R3
	MOVE W, AUX0, R4
	MOVE W, AUX0, R5
	MOVE W, AUX0, R6
	MOVE W, AUX0, R7
	MOVE W, AUX0, R8
	MOVE W, AUX0, R9
	MOVE W, AUX0, R10
	MOVE W, AUX0, R11
	MOVE W, AUX0, R12
	MOVE W, AUX0, R13
	MOVE W, AUX0, R14
	MOVE W, AUX0, R15
	MOVE W, AUX0, DAH
	MOVE W, AUX0, DAL
	MOVE W, AUX0, IAL
	MOVE W, AUX0, CAH
	MOVE W, AUX0, CAL
	MOVE W, AUX0, DD
	MOVE W, AUX0, ID
	MOVE W, AUX0, STATUS

	LIM H, AUX0, `LH INDICATOR_VALUE
	LIM L, AUX0, `LL INDICATOR_VALUE
	MOVE W, ZERO, DAH
	MOVE W, AUX0, DAL
	MOVE W, ZERO, DD

	LIM H, AUX0, `LH H_POSITION
	LIM L, AUX0, `LL H_POSITION
	MOVE W, ZERO, DAH
	MOVE W, AUX0, DAL
	MOVE W, ZERO, DD

	LIM H, AUX0, `LH H_VELOCITY
	LIM L, AUX0, `LL H_VELOCITY
	MOVE W, ZERO, DAH
	MOVE W, AUX0, DAL
	LIM W, AUX0, $FF
	MOVE W, AUX0, DD

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $01
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH CHR_COLOR
	LIM L, AUX1, `HL CHR_COLOR
	LIM H, AUX2, `LH CHR_COLOR
	LIM L, AUX2, `LL CHR_COLOR
	LIM W, AUX0, $0C
	MOVE W, AUX1, DAH
	MOVE W, AUX2, DAL
	MOVE W, AUX0, DD

	LIM H, AUX2, `LH CHR_BG_COLOR
	LIM L, AUX2, `LL CHR_BG_COLOR
	LIM W, AUX0, $03
	MOVE W, AUX2, DAL
	MOVE W, AUX0, DD

	LIM H, AUX1, `HH BUILD_CHR_PATTERN
	LIM L, AUX1, `HL BUILD_CHR_PATTERN
	LIM H, AUX0, `LH BUILD_CHR_PATTERN
	LIM L, AUX0, `LL BUILD_CHR_PATTERN
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $02
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH COPY_PATTERN_TO_MEM
	LIM L, AUX1, `HL COPY_PATTERN_TO_MEM
	LIM H, AUX0, `LH COPY_PATTERN_TO_MEM
	LIM L, AUX0, `LL COPY_PATTERN_TO_MEM
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $03
	MOVE W, AUX0, ID

	LIM H, AUX0, $20
	LIM L, AUX0, $04
	MOVE W, AUX0, R0

	LIM H, AUX1, `HH INIT_ATTRIBUTE
	LIM L, AUX1, `HL INIT_ATTRIBUTE
	LIM H, AUX0, `LH INIT_ATTRIBUTE
	LIM L, AUX0, `LL INIT_ATTRIBUTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $04
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH SET_ATTRIBUTE
	LIM L, AUX1, `HL SET_ATTRIBUTE
	LIM H, AUX0, `LH SET_ATTRIBUTE
	LIM L, AUX0, `LL SET_ATTRIBUTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $05
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH XGRI_TEST
	LIM L, AUX1, `HL XGRI_TEST
	LIM H, AUX0, `LH XGRI_TEST
	LIM L, AUX0, `LL XGRI_TEST
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $06
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH LOAD_TEST_STRING
	LIM L, AUX1, `HL LOAD_TEST_STRING
	LIM H, AUX0, `LH LOAD_TEST_STRING
	LIM L, AUX0, `LL LOAD_TEST_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $07
	MOVE W, AUX0, ID

	LDADDR DRAW_TEXT_OFFSET
	LIM H, AUX0, `LH 3212
	LIM L, AUX0, `LL 3212
	MOVE W, AUX0, DD

	LDADDR DRAW_TEXT_PALETTE
	LIM W, AUX0, $07
	MOVE W, AUX0, DD

	LIM H, AUX1, `HH DRAW_TEXT
	LIM L, AUX1, `HL DRAW_TEXT
	LIM H, AUX0, `LH DRAW_TEXT
	LIM L, AUX0, `LL DRAW_TEXT
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $08
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH SERIAL_PRINT_TEXT
	LIM L, AUX1, `HL SERIAL_PRINT_TEXT
	LIM H, AUX0, `LH SERIAL_PRINT_TEXT
	LIM L, AUX0, `LL SERIAL_PRINT_TEXT
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $09
	MOVE W, AUX0, ID

	LIM H, AUX0, `LH 200
	LIM L, AUX0, `LL 200
	MOVE W, AUX0, R0
	LIM W, AUX0, 12
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH 3390
	LIM L, AUX0, `LL 3390
	MOVE W, AUX0, R0
	LIM W, AUX0, 8
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH 3470
	LIM L, AUX0, `LL 3470
	MOVE W, AUX0, R0
	LIM W, AUX0, 9
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH 13070
	LIM L, AUX0, `LL 13070
	MOVE W, AUX0, R0
	LIM W, AUX0, 10
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH 19075
	LIM L, AUX0, `LL 19075
	MOVE W, AUX0, R0
	LIM W, AUX0, 10
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX0, `LH 9635
	LIM L, AUX0, `LL 9635
	MOVE W, AUX0, R0
	LIM W, AUX0, 11
	MOVE W, AUX0, R1

	LIM H, AUX1, `HH SET_ATTRIBUTE_STRING
	LIM L, AUX1, `HL SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH SET_ATTRIBUTE_STRING
	LIM L, AUX0, `LL SET_ATTRIBUTE_STRING
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $0A
	MOVE W, AUX0, ID

	LIM H, AUX1, `LH INTERRUPT_CONTROL
	LIM L, AUX1, `LL INTERRUPT_CONTROL
	MOVE W, AUX1, IAL
	LIM W, AUX0, $06
	MOVE W, AUX0, ID

	BRA MAIN
	NOP

	NOP
	NOP
	NOP
	NOP


BUILD_CHR_PATTERN
;CREATE CHR PATTERN FROM CHR ROW WITH SPECIFIED COLOR
	LIM H, AUX0, `LH CHR_ROM
	LIM L, AUX0, `LL CHR_ROM
	LIM H, AUX1, `LH CHR_PATTERN
	LIM L, AUX1, `LL CHR_PATTERN
	LIM H, AUX2, `LH CHR_BG_COLOR
	LIM L, AUX2, `LL CHR_BG_COLOR
	LIM H, AUX3, `LH CHR_COLOR			; Pointer to chr color pallete offset
	LIM L, AUX3, `LL CHR_COLOR

	MOVE W, AUX0, R0	;WE WILL KEEP POINTER TO CHR_ROM IN R0 FOR NOW
	MOVE W, AUX1, R1	;POINTER TO CHR_PATTERN IN R1
	MOVE W, AUX2, R5	;POINTER TO CHR_BG_COLOR IN R5
	MOVE W, AUX3, R3	;POINTER TO CHR_COLOR IN R3

	LIM H, AUX1, `LH CHR_ROM_END
	LIM L, AUX1, `LL CHR_ROM_END
	LIM W, AUX3, $00

	MOVE W, AUX1, R4	;POINTER TO CHR_ROM END IN R4
	MOVE W, AUX3, R6	;KEEP A ZERO HANDY IN R6

	;GET CHR COLOR IN R3
	MOVE W, R6, DAH
	MOVE W, R3, DAL
	MOVE W, DD, R3

	;GET BG COLOR IN R5
	MOVE W, R5, DAL
	MOVE W, DD, R5

BCP_LOOP_WORD
	;READ CHR WORD
	MOVE W, R6, DAH	;ZERO DAH
	MOVE W, R0, DAL	;POINT DAL TO CHR_ROM
	MOVE W, DD, R7	;PUT CHR WORD IN R7

	LIM W, AUX0, $03
	MOVE W, AUX0, R2	;START NIBBLE LOOP COUNTER AT 3

BCP_LOOP_NIBBLE
	MOVE W, R6, R9	;CLEAR R9 (USED TO HOLD RESULT WORD)

	;GET BIT 3
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_3
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_3
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 2
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_2
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_2
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_1
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_1
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_0
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_0
	;COPY NIBBLE TO R9, THIS IS THE LAST NIBBLE SO WE DON'T ROTATE
	OR W, R9, R9	;OR AUX0 WITH R9

	;WRITE THE PATTERN WORD TO MEMORY
	MOVE W, R6, DAH
	MOVE W, R1, DAL
	LIM W, AUX0, $01
	MOVE W, R9, DD
	ADD W, R1, R1	;INCREMENT POINTER TO CHR_PATTERN

	TEST W, R2
	LIM W, AUX0, $01
	BRNZ BCP_LOOP_NIBBLE
	SUB W, R2, R2	;DECREMENT NIBBLE LOOP COUNTER

	;CHECK IF WE ARE DONE AND INCREMENT CHR_ROM POINTER
	MOVE W, R0, AUX0
	XOR W, R4, AUX1	;COMPARE CHR_ROM POINTER TO CHR_ROM_END POINTER
	LIM W, AUX0, $01
	BRNZ BCP_LOOP_WORD
	ADD W, R0, R0	;INCREMENT CHR_ROM POINTER

	RET
	NOP


COPY_PATTERN_TO_MEM
	LIM H, AUX1, `LH CHR_PATTERN
	LIM L, AUX1, `LL CHR_PATTERN
	LIM H, AUX2, `LH CHR_PATTERN_END
	LIM L, AUX2, `LL CHR_PATTERN_END

	MOVE W, AUX1, R1	;POINTER TO CHR_PATTERN IN R1
	MOVE W, AUX2, R2	;POINTER TO CHR_PATTERN END IN R2

	LIM H, AUX1, `LH XGRI_PAR
	LIM L, AUX1, `LL XGRI_PAR
	MOVE W, AUX1, IAL				; Set I/O addr to addr of PAR
	LIM W, AUX0, $00
	MOVE W, AUX0, ID				; Fill PAR w/ 0
	MOVE W, AUX0, DAH				; Zero DAH

	LIM H, AUX1, `LH XGRI_STATUS	
	LIM L, AUX1, `LL XGRI_STATUS
	MOVE W, AUX1, R0				; KEEP IO POINTER TO XGRI_STATUS IN R0

	LIM H, AUX1, `LH XGRI_PDR	
	LIM L, AUX1, `LL XGRI_PDR
	MOVE W, AUX1, R3				; KEEP IO POINTER TO XGRI_PDR IN R3

	MOVE W, R0, IAL	;ADDRESS XGRI_STATUS

CPTM_LOOP
	BITT L, ID, 3		; CHECK P_FULL FLAG
	BRNZ CPTM_LOOP		; IF P_FULL IS SET KEEP WAITING
	MOVE W, R1, DAL		; Set DAL to "address of current pattern in CHR_PATTERN"

	MOVE W, R3, IAL		; ADDRESS XGRI_PDR
	MOVE W, R1, AUX0
	MOVE W, DD, ID		; Move pattern from CHR_PATTERN to PDR (PAR=n --> PAR=n+1)
	MOVE W, R0, IAL		; ADDRESS XGRI_STATUS
			
	; CHECK IF WE ARE DONE AND 
	; INCREMENT CHR_PATTERN POINTER
	XOR W, R2, AUX1		; COMPARE CHR_PATTERN POINTER TO CHR_PATTERN_END POINTER
	LIM W, AUX0, $01
	BRNZ CPTM_LOOP
	ADD W, R1, R1		; INCREMENT CHR_PATTERN POINTER

	RET
	NOP


INIT_ATTRIBUTE
	LIM H, AUX0, `LH ATTRIBUTE_BUF_END
	LIM L, AUX0, `LL ATTRIBUTE_BUF_END
	MOVE W, AUX0, R1
	LIM H, AUX0, `LH ATTRIBUTE_BUF
	LIM L, AUX0, `LL ATTRIBUTE_BUF
	MOVE W, AUX0, DAL
	LIM W, AUX0, $00
	MOVE W, AUX0, DAH
IA_LOOP
	MOVE W, R0, DD
	MOVE W, R1, AUX0
	XOR W, DAL, AUX0
	LIM W, AUX0, $01
	BRNZ IA_LOOP
	ADD W, DAL, DAL
	RET
	NOP


SET_ATTRIBUTE
	LIM H, AUX1, `LH XGRI_STATUS	
	LIM L, AUX1, `LL XGRI_STATUS
	MOVE W, AUX1, R0	;KEEP IO POINTER TO XGRI_STATUS IN R0

	LIM H, AUX1, `LH XGRI_ADR	
	LIM L, AUX1, `LL XGRI_ADR
	MOVE W, AUX1, R3	;KEEP IO POINTER TO XGRI_ADR IN R3

	LIM H, AUX1, `LH XGRI_AAR
	LIM L, AUX1, `LL XGRI_AAR
	MOVE W, AUX1, R2	;KEEP IO POINTER TO XGRI_AAR IN R2
	MOVE W, AUX1, IAL	; Set I/O addr to addr of AAR
	LIM W, AUX0, $00
	MOVE W, AUX0, ID	; ZERO AAR

	LIM H, AUX2, $20 
	LIM L, AUX2, $04	;KEEP EOT CHAR IN AUX2

	LIM H, AUX1, `LH 19200
	LIM L, AUX1, `LL 19200
	MOVE W, AUX1, R1	;START LOOP COUNTER AT 19200

	MOVE W, R0, IAL		;ADDRESS XGRI_STATUS
	LIM W, AUX0, $01

SET_ATTRIBUTE_LOOP
	BITT L, ID, 1		;XGRI HAS 2 CYCLE DATA TO STATUS LATENCY
	BITT L, ID, 1		;CHECK A_FULL FLAG
	BRNZ SET_ATTRIBUTE_LOOP		;IF A_FULL IS SET KEEP WAITING
	NOP

	MOVE W, R3, IAL		;ADDRESS XGRI_ADR
	MOVE W, AUX2, ID 	;WRITE ATTRIBUTE

	SUB W, R1, R1
	BRNZ SET_ATTRIBUTE_LOOP
	MOVE W, R0, IAL		;ADDRESS XGRI_STATUS

	;SET CORNERS TO A DIFFERENT TILE
	;TOP LEFT
	LIM H, AUX0, $50
	LIM L, AUX0, $2A	;PUT ATTRIBUTE IN AUX0

	MOVE W, AUX0, R4
	LIM H, AUX1, `HH SET_TILE_ATTRIBUTE
	LIM L, AUX1, `HL SET_TILE_ATTRIBUTE
	LIM H, AUX0, `LH SET_TILE_ATTRIBUTE
	LIM L, AUX0, `LL SET_TILE_ATTRIBUTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL

	LIM W, AUX1, 0
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP

	;TOP RIGHT
	LIM W, AUX1, 79
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP

	;BOTTOM LEFT
	LIM H, AUX1, `LH 9440
	LIM L, AUX1, `LL 9440
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP

	;BOTTOM RIGHT
	LIM H, AUX1, `LH 9519
	LIM L, AUX1, `LL 9519
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP

	;MIDDLE 4
	;TOP LEFT
	LIM H, AUX1, `LH 4679
	LIM L, AUX1, `LL 4679
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP
	;TOP RIGHT
	LIM H, AUX1, `LH 4680
	LIM L, AUX1, `LL 4680
	MOVE W, AUX1, R0
	MOVE W, R4, R1
	CALL
	NOP

	RET
	NOP


XGRI_TEST
	LIM H, AUX0, `LH XGRI_STATUS
	LIM L, AUX0, `LL XGRI_STATUS
	MOVE W, AUX0, IAL	;ADDRESS XGRI_STATUS
	BITT W, ID, 7		;CHECK BUSY FLAG
	BRNZ XGRI_TEST		;IF BUSY FLAG IS SET KEEP WAITING
	BITT W, ID, 0		;CHECK A_EMPTY FLAG
	BRZ XGRI_TEST		;IF ATTRIBUTE FIFO NOT EMPTY KEEP WAITING
	NOP

	LIM H, AUX1, `LH XGRI_AAR
	LIM L, AUX1, `LL XGRI_AAR
	MOVE W, AUX1, IAL
	LIM W, AUX0, 16
	MOVE W, AUX0, ID

	LIM H, AUX1, `LH XGRI_ADR
	LIM L, AUX1, `LL XGRI_ADR
	MOVE W, AUX1, IAL
	LIM H, AUX0, `LH $002A
	LIM L, AUX0, `LL $002A
	MOVE W, AUX0, ID

	MOVE W, AUX0, ID
	MOVE W, AUX0, ID
	MOVE W, AUX0, ID

	RET
	NOP


LOAD_TEST_STRING
	LIM W, AUX0, $00
	MOVE W, AUX0, DAH
	LIM H, AUX1, `LH TEST_STRING
	LIM L, AUX1, `LL TEST_STRING
	LIM H, AUX2, `LH TEXT_BUFFER
	LIM L, AUX2, `LL TEXT_BUFFER
	LIM W, AUX0, $01
LOAD_TEST_STRING_LOOP
	MOVE W, AUX1, DAL
	ADD W, AUX1, AUX1
	MOVE W, DD, R0
	MOVE W, AUX2, DAL
	ADD W, AUX2, AUX2
	MOVE W, R0, DD
	BRNZ LOAD_TEST_STRING_LOOP
	NOP
LOAD_TEST_STRING_DONE
	RET
	NOP


DRAW_TEXT
	LIM H, AUX0, `LH XGRI_STATUS
	LIM L, AUX0, `LL XGRI_STATUS
	MOVE W, AUX0, IAL
	BITT W, ID, 7	;CHECK BUSY FLAG
	BRNZ DRAW_TEXT	;IF BUSY FLAG IS SET KEEP WAITING
	BITT W, ID, 0	;CHECK A_EMPTY FLAG
	BRZ DRAW_TEXT	;IF ATTRIBUTE FIFO NOT EMPTY KEEP WAITING
	NOP
	IADDR XGRI_AAR					; SET IO ADDRESS TO XGRI ATTRIBUTE ADDRESS REGISTER
	LDADDR DRAW_TEXT_OFFSET			; SET DATA ADDRESS TO DRAW TEXT OFFSET
	MOVE W, DD, ID					; MOVE DRAW_TEXT_OFFSET TO XGRI_AAR
	SPLOAD DRAW_TEXT_PALETTE, R1	; PUT PALETTE FOR TEXT IN R1
	SDADDR TEXT_BUFFER				; SET DATA ADDRESS TO START OF TEXT BUFFER
	ROR W, R1, R1					; PUT PALETTE FOR TEXT IN HIGH 4 BITS OF R1		
	ROR W, R1, R1
	ROR W, R1, R1
	ROR W, R1, R1
DRAW_TEXT_CHECK
	MOVE W, DD, R0			; PUT CHAR IN R0
	BRNZ DRAW_TEXT_WAIT		; CHECK IF CHAR IS NULL
	NOP
	RET						; DONE IF CHAR IS NULL
	NOP
DRAW_TEXT_WAIT
	NOP
	IADDR XGRI_STATUS		; SET IO ADDR TO STATUS 
	BITT L, ID, 1			; Status[1] (a_full) -> Z Reg
	BRNZ DRAW_TEXT_WAIT
	NOP
DRAW_TEXT_SET
	IADDR XGRI_ADR			; SET IO ADDR TO ATTRIBUTE DATA
	MOVE W, R1, AUX0		
	OR W, R0, R0			; R0[0000,CHAR] | R1/AUX0[PALT,0000 0000 0000]
	MOVE W, R0, ID			; PUT CHAR IN ATTRIBUTE TABLE

	LIM W, AUX0, $01
	ADD W, DAL, DAL			; INCREMENT CHAR INDEX
	BRA DRAW_TEXT_CHECK	
	NOP


MAIN
	LIM H, AUX1, `HH SERIAL_GET_BYTE
	LIM L, AUX1, `HL SERIAL_GET_BYTE
	LIM H, AUX0, `LH SERIAL_GET_BYTE
	LIM L, AUX0, `LL SERIAL_GET_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `HH SERIAL_SEND_BYTE
	LIM L, AUX1, `HL SERIAL_SEND_BYTE
	LIM H, AUX0, `LH SERIAL_SEND_BYTE
	LIM L, AUX0, `LL SERIAL_SEND_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	MOVE W, R11, R0
	CALL
	NOP

	MOVE S, R11, R11

	LIM H, AUX1, `HH SERIAL_GET_BYTE
	LIM L, AUX1, `HL SERIAL_GET_BYTE
	LIM H, AUX0, `LH SERIAL_GET_BYTE
	LIM L, AUX0, `LL SERIAL_GET_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `HH SERIAL_SEND_BYTE
	LIM L, AUX1, `HL SERIAL_SEND_BYTE
	LIM H, AUX0, `LH SERIAL_SEND_BYTE
	LIM L, AUX0, `LL SERIAL_SEND_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	MOVE W, R11, R0
	CALL
	NOP

	LIM H, AUX0, `LH XGRI_VSCROLL
	LIM L, AUX0, `LL XGRI_VSCROLL
	MOVE W, AUX0, IAL
	MOVE W, R11, ID

	LIM H, AUX1, `HH SERIAL_GET_BYTE
	LIM L, AUX1, `HL SERIAL_GET_BYTE
	LIM H, AUX0, `LH SERIAL_GET_BYTE
	LIM L, AUX0, `LL SERIAL_GET_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `HH SERIAL_SEND_BYTE
	LIM L, AUX1, `HL SERIAL_SEND_BYTE
	LIM H, AUX0, `LH SERIAL_SEND_BYTE
	LIM L, AUX0, `LL SERIAL_SEND_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	MOVE W, R11, R0
	CALL
	NOP

	MOVE S, R11, R11

	LIM H, AUX1, `HH SERIAL_GET_BYTE
	LIM L, AUX1, `HL SERIAL_GET_BYTE
	LIM H, AUX0, `LH SERIAL_GET_BYTE
	LIM L, AUX0, `LL SERIAL_GET_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `HH SERIAL_SEND_BYTE
	LIM L, AUX1, `HL SERIAL_SEND_BYTE
	LIM H, AUX0, `LH SERIAL_SEND_BYTE
	LIM L, AUX0, `LL SERIAL_SEND_BYTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	MOVE W, R11, R0
	CALL
	NOP

	LIM H, AUX0, `LH XGRI_HSCROLL
	LIM L, AUX0, `LL XGRI_HSCROLL
	MOVE W, AUX0, IAL
	MOVE W, R11, ID

	BRA MAIN
	NOP


HALT
	LIM W, AUX0, $01
HALT_LOOP
	ADD W, R0, R0
	LIM W, AUX0, $00
	ADDC W, R1, R1
	ADDC W, R2, R2
	ADDC W, R3, R3
	BRA HALT_LOOP
	LIM W, AUX0, $01


;MODIFIES REGISTERS: AUX0, R2, R3, DAH, DAL, IAL
; R0 HAS ATTRIBUTE INDEX
; R1 HAS ATTRIBUTE VALUE
SET_TILE_ATTRIBUTE
	LIM H, AUX0, `LH XGRI_STATUS
	LIM L, AUX0, `LL XGRI_STATUS
	MOVE W, AUX0, IAL		;ADDRESS XGRI_STATUS
	BITT W, ID, 7			;CHECK BUSY FLAG
	BRNZ SET_TILE_ATTRIBUTE	;IF BUSY FLAG IS SET KEEP WAITING
	BITT W, ID, 0			;CHECK A_EMPTY FLAG
	BRZ SET_TILE_ATTRIBUTE	;IF ATTRIBUTE FIFO NOT EMPTY KEEP WAITING
	NOP

	LIM H, AUX0, `LH XGRI_AAR
	LIM L, AUX0, `LL XGRI_AAR
	MOVE W, AUX0, IAL	;ADDRESS XGRI_AAR

	LIM W, AUX0, $FC
	AND W, R0, R2	;COMPUTE BASE INDEX (INDEX - INDEX % 4)
	MOVE W, R2, ID	;SET XGRI_AAR TO BASE INDEX

	LIM W, AUX0, $00
	MOVE W, AUX0, DAH
	LIM H, AUX0, `LH ATTRIBUTE_BUF
	LIM L, AUX0, `LL ATTRIBUTE_BUF
	ADD W, R0, DAL		;SET DAL TO ADDRESS OF ATTRIBUTE IN BUFFER
	ADD W, R2, R3		;COMPUTE BASE ADDRESS IN BUFFER
	MOVE W, R1, DD		;WRITE ATTRIBUTE DATA IN BUFFER

	LIM H, AUX0, `LH XGRI_ADR
	LIM L, AUX0, `LL XGRI_ADR
	MOVE W, AUX0, IAL	;ADDRESS XGRI_ADR
	MOVE W, R3, DAL		;ADDRESS BASE OF ATTRIBUTE BURST
	LIM W, AUX0, $01

	MOVE W, DD, ID
	ADD W, DAL, DAL
	MOVE W, DD, ID
	ADD W, DAL, DAL
	MOVE W, DD, ID
	ADD W, DAL, DAL
	MOVE W, DD, ID

	RET
	NOP

;R0 HAS ATTRIBUTE INDEX
;R1 HAS THE PALETTE ID
SET_ATTRIBUTE_STRING
	LIM H, AUX0, `LH TEXT_BUFFER
	LIM L, AUX0, `LL TEXT_BUFFER
	MOVE W, AUX0, DAL
	MOVE W, AUX0, R4	;KEEP POINTER TO STRING IN R4
	LIM W, AUX0, $00
	MOVE W, AUX0, DAH
	MOVE W, AUX0, R5	;CLEAR R5 FOR LATER USE
	TEST W, DD
	BRZ SAS_DONE	;IF STRING IS NULL SKIP THE WHOLE THING

	ROR W, R1, AUX2
	ROR W, AUX2, AUX2
	ROR W, AUX2, AUX2
	ROR W, AUX2, AUX2

	LIM H, AUX0, `LH XGRI_STATUS
	LIM L, AUX0, `LL XGRI_STATUS
	MOVE W, AUX0, IAL
SAS_WAIT
	BITT W, ID, 7		;CHECK BUSY FLAG
	BRNZ SAS_WAIT
	BITT W, ID, 0		;CHECK A_EMPTY FLAG
	BRZ SAS_WAIT

	LIM H, AUX0, `LH XGRI_AAR
	LIM L, AUX0, `LL XGRI_AAR
	MOVE W, AUX0, IAL	;ADDRESS XGRI_AAR

	LIM W, AUX0, $FC
	AND W, R0, R2		;COMPUTE BASE INDEX (INDEX - INDEX % 4)
	MOVE W, R2, ID		;SET XGRI_AAR TO BASE INDEX

	LIM H, AUX0, `LH ATTRIBUTE_BUF
	LIM L, AUX0, `LL ATTRIBUTE_BUF
	ADD W, R0, R3		;COMPUTE ADDRESS OF ATTRIBUTE IN BUFFER
	ADD W, R2, R2		;COMPUTE BASE ADDRESS IN BUFFER

	;WRITE STRING TO BUFFER AND COUNT LENGTH
	MOVE W, R4, DAL		;POINT TO NEXT CHAR IN STRING
	LIM W, AUX0, $01
SAS_COPY
	MOVE W, DD, AUX1		;GET CHAR
	BRZ SAS_COPY_DONE
	ADD W, R4, R4		;INCREMENT STRING POINTER
	MOVE W, R3, DAL		;POINT TO ATTRIBUTE BUFFER
	ADD W, R5, R5		;INCREMENT LENGTH COUNTER
	ADD W, R3, R3		;INCREMENT ATTRIBUTE BUFFER POINTER
	MOVE W, AUX2, AUX0	
	OR W, AUX1, DD		;WRITE CHAR(Palette# | Pattern#) TO MEMORY
	LIM W, AUX0, $01
	BRA SAS_COPY
	MOVE W, R4, DAL		;POINT TO NEXT CHAR

SAS_COPY_DONE
	;WE WANT TO COMPUTE LENGTH + OFFSET ROUNDED UP TO MULTIPLE OF 4 (((LENGTH + OFFSET) + 3) - (((LENGTH + OFFSET) + 3) % 4))
	LIM W, AUX0, $03
	AND W, R0, AUX1		;GET OFFSET OF FIRST ATTRIBUTE FROM BASE INDEX (INDEX % 4)
	ADD W, AUX1, AUX0		;COMPUTE OFFSET + 3
	ADD W, R5, R5		;COMPUTE LENGTH + OFFSET + 3
	LIM W, AUX0, $FC
	AND W, R5, R5		;ROUND UP LENGTH + OFFSET TO MULTIPLE OF 4

	;MOVE W, R2, DAL		;POINT TO NEXT ATTRIBUTE IN BUFFER
	LIM H, AUX0, `LH XGRI_STATUS
	LIM L, AUX0, `LL XGRI_STATUS
	MOVE W, AUX0, AUX1	;AUX1 NOW HAS POINTER TO XGRI_STATUS
	MOVE W, AUX0, IAL	;ADDRESS XGRI_STATUS
	LIM H, AUX0, `LH XGRI_ADR
	LIM L, AUX0, `LL XGRI_ADR
	MOVE W, AUX0, R4	;R4 NOW HAS IO POINTER TO XGRI_ADR
	LIM W, AUX0, $01
SAS_WRITE
	BITT W, ID, 7		;CHECK BUSY FLAG
	BRNZ SAS_WRITE
	BITT W, ID, 1		;CHECK A_FULL FLAG
	BRNZ SAS_WRITE
	MOVE W, R2, DAL		;POINT TO NEXT ATTRIBUTE IN BUFFER
	MOVE W, R4, IAL		;ADDRESS XGR_ADR
	ADD W, R2, R2		;INCREMENT POINTER TO ATTRIBUTE BUFFER
	MOVE W, DD, ID		;WRITE ATTRIBUTE
	SUB W, R5, R5		;DECREMENT LENGTH COUNTER
	BRNZ SAS_WRITE
	MOVE W, AUX1, IAL	;ADDRESS XGRI_STATUS

SAS_DONE
	RET
	NOP


;MODIFIES REGISTERS: AUX0, AUX1, R0, DAH, DAL, CAH, CAL, IAL
SERIAL_PRINT_TEXT
	LIM H, AUX0, `HH TEXT_BUFFER
	LIM L, AUX0, `HL TEXT_BUFFER
	LIM H, AUX1, `LH TEXT_BUFFER
	LIM L, AUX1, `LL TEXT_BUFFER
	MOVE W, AUX0, DAH
	MOVE W, AUX1, DAL
	LIM H, AUX0, `HH SERIAL_SEND_BYTE
	LIM L, AUX0, `HL SERIAL_SEND_BYTE
	LIM H, AUX1, `LH SERIAL_SEND_BYTE
	LIM L, AUX1, `LL SERIAL_SEND_BYTE
	MOVE W, AUX0, CAH
	MOVE W, AUX1, CAL
SPT_CHECK
	MOVE W, DD, R0			; PUT CHAR IN R0
	BRNZ SPT_NN		; CHECK IF CHAR IS NULL
	NOP
	RET						; DONE IF CHAR IS NULL
	NOP
SPT_NN
	CALL
	NOP
	LIM W, AUX0, $01
	BRA SPT_CHECK	
	ADD W, DAL, DAL			; INCREMENT CHAR INDEX


;MODIFIES REGISTERS: AUX0, AUX1, AUX2, R0, R1, R2, R3
DIV16
; R2 = R0 / R1
; R3 USED AS INDEX
	TEST W, R1
	BRNZ DIV16_NZ
	LIM W, AUX0, $00
	RET
	NOP
DIV16_NZ
	LIM W, AUX1, $01
	MOVE W, AUX0, R2	;CLEAR RESULT
	MOVE W, AUX1, R3	;SET INDEX TO 1
SHIFT_IT16
	BITT W, R1, 15
	BRNZ DIV16_LOOP	;IF MSB OF DENOMINATOR IS SET GOTO DIV16_LOOP
	NOP
	ROL W, R1, R1
	BRA SHIFT_IT16
	ROL W, R3, R3	;SHIFT LEFT DENOMINATOR AND INDEX
DIV16_LOOP
	MOVE W, R1, AUX0
	SUB W, R0, AUX2	;SUBTRACT DENOMINATOR FROM NUMERATOR
	BRN FINAL16	;IF THE RESULT IS NEGATIVE GOTO FINAL16
	MOVE W, R3, AUX0	;PUT INDEX IN AUX0
	MOVE W, AUX2, R0	;MAKE THE SUBTRACTION RESULT THE NEW NUMERATOR
	ADD W, R2, R2	;ADD INDEX TO THE RESULT
FINAL16
	LIM H, AUX0, $7F
	LIM L, AUX0, $FF
	ROR W, R3, R3
	ROR W, R1, R1
	AND W, R3, R3	;SHIFT RIGHT INDEX
	BRNZ DIV16_LOOP
	AND W, R1, R1	;SHIFT RIGHT DENOMINATOR
	RET
	NOP


;MODIFIES REGISTERS: AUX0, R0, R1, R2
MUL16
; R2 = R0 * R1
	LIM W, AUX0, $00
	MOVE W, AUX0, R2	;CLEAR RESULT
MACC16
; R2 = R0 * R1 + R2
	BITT W, R0, 0
	BRZ MACC16_SHIFT	;IF LSB OF R0 IS CLEARED SKIP ADDING
	MOVE W, R1, AUX0
MACC16_ADD
	ADD W, R2, R2	;ADD R1 TO THE RESULT
MACC16_SHIFT
	LIM W, AUX0, $FE
	ROL W, R1, R1
	AND W, R0, R0
	ROR W, R0, R0	;SHIFT RIGHT R0
	BRNZ MACC16
	AND W, R1, R1	;SHIFT LEFT R1
	RET
	NOP


;MODIFIES REGISTERS: AUX0, R11, IAL
SERIAL_GET_BYTE
; CHECK THAT UART IS READY
	LIM H, AUX0, `LH UART_STATUS
	LIM L, AUX0, `LL UART_STATUS
	MOVE W, AUX0, IAL
SGB_WAIT
	BITT W, ID, 7	;CHECK BUSY FLAG
	BRNZ SGB_WAIT
	BITT W, ID, 3	;CHECK RX READY FLAG
	BRZ SGB_WAIT	;IF NOT SET KEEP WAITING
	LIM L, AUX0, `LL UART_DATA
	MOVE W, AUX0, IAL
	RET
	MOVE L, ID, R11


;MODIFIES REGISTERS: AUX0, IAL
SERIAL_SEND_BYTE
; CHECK THAT UART IS READY
	LIM H, AUX0, `LH UART_STATUS
	LIM L, AUX0, `LL UART_STATUS
	MOVE W, AUX0, IAL
SSB_WAIT
	BITT W, ID, 7	;CHECK BUSY FLAG
	BRNZ SSB_WAIT
	BITT W, ID, 2	;CHECK TX READY FLAG
	BRZ SSB_WAIT
	LIM L, AUX0, `LL UART_DATA
	MOVE W, AUX0, IAL
	RET
	MOVE L, R0, ID

HEX_INC
	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM H, AUX1, `LH INDICATOR_VALUE
	LIM L, AUX1, `LL INDICATOR_VALUE
	MOVE W, ZERO, DAH
	MOVE W, AUX1, DAL
	LIM W, AUX0, $01
	ADD W, DD, AUX0
	MOVE W, AUX0, ID
	RET
	MOVE W, AUX0, DD

TEST_STRING
	DATA 'H'
	DATA 'E'
	DATA 'L'
	DATA 'L'
	DATA 'O'
	DATA '\S'
	DATA 'W'
	DATA 'O'
	DATA 'R'
	DATA 'L'
	DATA 'D'
	DATA '!'
	DATA $00



	ORG $0C00	;PLACE CHR ROM
INCLUDE "NF_CHR.INC"
