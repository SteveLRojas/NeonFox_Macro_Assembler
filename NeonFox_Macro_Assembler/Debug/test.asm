;                     /\         /\__
;                   // \       (  0 )_____/\            __
;                  // \ \     (vv          o|          /^v\
;                //    \ \   (vvvv  ___-----^        /^^/\vv\
;              //  /     \ \ |vvvvv/               /^^/    \v\
;             //  /       (\\/vvvv/              /^^/       \v\
;            //  /  /  \ (  /vvvv/              /^^/---(     \v\
;           //  /  /    \( /vvvv/----(O        /^^/           \v\
;          //  /  /  \  (/vvvv/               /^^/             \v|
;        //  /  /    \( vvvv/                /^^/               ||
;       //  /  /    (  vvvv/                 |^^|              //
;      //  / /    (  |vvvv|                  /^^/            //
;     //  / /   (    \vvvvv\          )-----/^^/           //
;    // / / (          \vvvvv\            /^^^/          //
;   /// /(               \vvvvv\        /^^^^/          //
;  ///(              )-----\vvvvv\    /^^^^/-----(      \\
; //(                        \vvvvv\/^^^^/               \\
;/(                            \vvvv^^^/                 //
;                                \vv^/         /        //
;                                             /<______//
;                                            <<<------/
;                                             \<
;                                              \
;**************************************************
;* NEONFOX_TEST.ASM           SOURCE FILE         *
;* Copyright (C) 2022 Esteban Looser-Rojas.       *
;* Contains test program for the NeonFox          *
;* processor validation platform.                 *
;**************************************************

INCLUDE "NEONFOX.INC"

;VARIABLES
CHR_PATTERN EQU $1000
CHR_PATTERN_END EQU $1FFF
CHR_COLOR EQU $2000
CHR_BG_COLOR EQU $2001

MACRO MTEST ARG1, ARG2, ARG3
	LIM H, AUX0, `LH ARG1
	LIM L, AUX0, `LL ARG1
	LIM H, AUX1, `LH ARG2
	LIM L, AUX1, `LL ARG2
ENDMACRO MTEST

MACRO OTHER X, Y, Z
SNOOPY LIM X, Y, Z
	NOP
ENDMACRO OTHER

	ORG 0
	BRA INT_RESET
	NOP
	RET	;INT1
	NOP
	RET ;INT2
	NOP
	RET	;INT3
	NOP
	RET	;INT4
	NOP
	RET	;INT5
	NOP
	RET	;INT6
	NOP
	RET	;INT7
	NOP
	RET	;INT8
	NOP
	RET ;INT9
	NOP
	RET	;INT10
	NOP
	RET	;INT11
	NOP
	RET	;INT12
	NOP
	RET	;INT13
	NOP
	RET	;INT14
	NOP
	RET ;INT15
	NOP

EGG	MTEST $DEAD, $BEEF, NOODLES

DOG OTHER H, AUX0, $BADC0FFEE

INT_RESET
;SET ALL REGISTERS TO ZERO
	LIM W, AUX0, $00
	LIM W, AUX1, $00
	MOVE W, AUX0, AUX2
	MOVE W, AUX1, AUX3
	MOVE W, AUX0, R0
	MOVE W, AUX0, R1
	MOVE W, AUX0, R2
	MOVE W, AUX0, R3
	MOVE W, AUX0, R4
	MOVE W, AUX0, R5
	MOVE W, AUX0, R6
	MOVE W, AUX0, R7
	MOVE W, AUX0, R8
	MOVE W, AUX0, R9
	MOVE W, AUX0, R10
	MOVE W, AUX0, R11
	MOVE W, AUX0, R12
	MOVE W, AUX0, R13
	MOVE W, AUX0, R14
	MOVE W, AUX0, R15
	MOVE W, AUX0, DAH
	MOVE W, AUX0, DAL
	MOVE W, AUX0, IAL
	MOVE W, AUX0, CAH
	MOVE W, AUX0, CAL
	MOVE W, AUX0, DD
	MOVE W, AUX0, ID
	MOVE W, AUX0, STATUS
	MOVE W, AUX0, CONTROL

	LIM H, AUX1, `LH MSC_D_CONTROL
	LIM L, AUX1, `LL MSC_D_CONTROL
	MOVE W, AUX1, IAL
	LIM W, AUX1, `HL MSC_D_CONTROL
	MOVE W, AUX1, IAH
	LIM W, AUX0, MSC_CMD_ENABLE
	MOVE W, AUX0, ID

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $01
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH CACHE_TEST
	LIM L, AUX1, `HL CACHE_TEST
	LIM H, AUX0, `LH CACHE_TEST
	LIM L, AUX0, `LL CACHE_TEST
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $02
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH SET_PATTERN
	LIM L, AUX1, `HL SET_PATTERN
	LIM H, AUX0, `LH SET_PATTERN
	LIM L, AUX0, `LL SET_PATTERN
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $03
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH SET_ATTRIBUTE
	LIM L, AUX1, `HL SET_ATTRIBUTE
	LIM H, AUX0, `LH SET_ATTRIBUTE
	LIM L, AUX0, `LL SET_ATTRIBUTE
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $04
	MOVE W, AUX0, ID

	LIM H, AUX1, `LH MSC_D_CONTROL
	LIM L, AUX1, `LL MSC_D_CONTROL
	MOVE W, AUX1, IAL
	LIM W, AUX0, MSC_CMD_FLUSH
	MOVE W, AUX0, ID

	NOP
	NOP
	NOP
	NOP
	NOP

	MOVE W, DD, AUX0	;WAIT FOR CACHE FLUSH TO COMPLETE

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $05
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH XGRI_TEST
	LIM L, AUX1, `HL XGRI_TEST
	LIM H, AUX0, `LH XGRI_TEST
	LIM L, AUX0, `LL XGRI_TEST
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $06
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH BUILD_CHR_PATTERN
	LIM L, AUX1, `HL BUILD_CHR_PATTERN
	LIM H, AUX0, `LH BUILD_CHR_PATTERN
	LIM L, AUX0, `LL BUILD_CHR_PATTERN
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $07
	MOVE W, AUX0, ID

	LIM H, AUX1, `HH COPY_PATTERN_TO_MEM
	LIM L, AUX1, `HL COPY_PATTERN_TO_MEM
	LIM H, AUX0, `LH COPY_PATTERN_TO_MEM
	LIM L, AUX0, `LL COPY_PATTERN_TO_MEM
	MOVE W, AUX1, CAH
	MOVE W, AUX0, CAL
	CALL
	NOP

	LIM H, AUX1, `LH HEX_INDICATORS
	LIM L, AUX1, `LL HEX_INDICATORS
	MOVE W, AUX1, IAL
	LIM W, AUX0, $08
	MOVE W, AUX0, ID

	BRA HALT
	NOP

	NOP
	NOP
	NOP
	NOP

HALT
	LIM W, AUX0, $01
HALT_LOOP
	ADD W, R0, R0
	LIM W, AUX0, $00
	ADDC W, R1, R1
	ADDC W, R2, R2
	ADDC W, R3, R3
	BRA HALT_LOOP
	LIM W, AUX0, $01

SET_PATTERN
	LIM W, AUX1, $02
	MOVE W, AUX1, DAH
	LIM H, AUX0, $10
	LIM L, AUX0, $00
	MOVE W, AUX0, DAL

	LIM W, AUX0, $01

;      0  1  2  3  4  5  6  7 
;   --------------------------
; 0 |  0  7  0  0  0  7  0  0
; 1 |  0  7  7  0  0  7  0  0
; 2 |  0  7  0  7  0  7  0  0
; 3 |  0  7  0  0  7  7  0  0
; 4 |  0  7  0  7  0  7  0  7
; 5 |  0  0  0  7  0  0  0  7
; 6 |  0  0  0  7  0  0  0  7
; 7 |  0  0  0  0  7  7  7  0

	; Line 0
	LIM H, AUX2, $07
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $07
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; Line 1
	LIM H, AUX2, $07
	LIM L, AUX2, $70
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $07
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 2
	LIM H, AUX2, $07
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $07
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 3
	LIM H, AUX2, $07
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $77
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 4
	LIM H, AUX2, $07
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $07
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 5
	LIM H, AUX2, $00
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $00
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 6
	LIM H, AUX2, $00
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $00
	LIM L, AUX2, $07
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 7
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $77
	LIM L, AUX2, $70
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

;      0  1  2  3  4  5  6  7 
;   --------------------------
; 0 |  0  0  0  0  0  0  0  0
; 1 |  0  1  1  0  0  1  1  0
; 2 |  0  0  1  1  1  1  0  0
; 3 |  1  1  1  1  1  1  1  1
; 4 |  0  0  1  1  1  1  0  0
; 5 |  0  1  1  0  0  1  1  0
; 6 |  0  0  0  0  0  0  0  0
; 7 |  0  0  0  0  0  0  0  0

	; Line 0
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; Line 1
	LIM H, AUX2, $09
	LIM L, AUX2, $90
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $09
	LIM L, AUX2, $90
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 2
	LIM H, AUX2, $00
	LIM L, AUX2, $99
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $99
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 3
	LIM H, AUX2, $99
	LIM L, AUX2, $99
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $99
	LIM L, AUX2, $99
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 4
	LIM H, AUX2, $00
	LIM L, AUX2, $99
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $99
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 5
	LIM H, AUX2, $09
	LIM L, AUX2, $90
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $09
	LIM L, AUX2, $90
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 6
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	; LINE 7
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL
	LIM H, AUX2, $00
	LIM L, AUX2, $00
	MOVE W, AUX2, DD
	ADD W, DAL, DAL

	RET
	NOP

SET_ATTRIBUTE
	LIM W, AUX1, $03
	MOVE W, AUX1, DAH
	LIM H, AUX0, $12
	LIM L, AUX0, $BF
	MOVE W, AUX0, DAL		; Start at top of Attribute memory 

	LIM H, AUX2, $21 		; Filling  
	LIM L, AUX2, $00

SET_ATTRIBUTE_LOOP
	MOVE W, AUX2, DD 		; Fill
	LIM W, AUX0, $01
	SUB W, DAL, DAL			; Move down Attribute memory
	BRNN SET_ATTRIBUTE_LOOP
	NOP

	;SET CORNERS TO A DIFFERENT TILE
	;TOP LEFT
	LIM W, AUX0, $00
	LIM H, AUX2, $51
	LIM L, AUX2, $01
	MOVE W, AUX0, DAL
	MOVE W, AUX2, DD

	;TOP RIGHT
	LIM W, AUX0, $4F
	MOVE W, AUX0, DAL
	MOVE W, AUX2, DD

	;BOTTOM LEFT
	LIM H, AUX0, $12
	LIM L, AUX0, $70
	MOVE W, AUX0, DAL
	MOVE W, AUX2, DD

	;BOTTOM RIGHT
	LIM H, AUX0, $12
	LIM L, AUX0, $BF
	MOVE W, AUX0, DAL
	MOVE W, AUX2, DD

	;MIDDLE
	LIM H, AUX0, $09
	LIM L, AUX0, $37
	MOVE W, AUX0, DAL
	MOVE W, AUX2, DD

	RET
	NOP

CACHE_TEST
	LIM W, AUX3, $01
	LIM H, AUX2, $F0
	LIM L, AUX2, $00
	LIM W, AUX1, $F1
	MOVE W, AUX3, DAH
	MOVE W, AUX2, DAL
	MOVE W, AUX1, DD

	LIM W, AUX3, $02
	LIM W, AUX1, $F2
	MOVE W, AUX3, DAH
	MOVE W, AUX1, DD

	LIM W, AUX3, $03
	LIM W, AUX1, $F3
	MOVE W, AUX3, DAH
	MOVE W, AUX1, DD

	LIM W, AUX3, $04
	LIM W, AUX1, $F4
	MOVE W, AUX3, DAH
	MOVE W, AUX1, DD

	RET
	NOP

XGRI_TEST
	LIM H, AUX1, `LH XGRI_AAR
	LIM L, AUX1, `LL XGRI_AAR
	MOVE W, AUX1, IAL
	LIM W, AUX0, 16
	MOVE W, AUX0, ID

	LIM H, AUX1, `LH XGRI_ADR
	LIM L, AUX1, `LL XGRI_ADR
	MOVE W, AUX1, IAL
	LIM H, AUX0, `LH $0101
	LIM L, AUX0, `LL $0101
	MOVE W, AUX0, ID

	MOVE W, AUX0, ID
	MOVE W, AUX0, ID
	MOVE W, AUX0, ID

	RET
	NOP

BUILD_CHR_PATTERN
;CREATE CHR PATTERN FROM CHR ROW WITH SPECIFIED COLOR
	LIM H, AUX0, `LH CHR_ROM
	LIM L, AUX0, `LL CHR_ROM
	LIM H, AUX1, `LH CHR_PATTERN
	LIM L, AUX1, `LL CHR_PATTERN
	LIM H, AUX2, `LH CHR_PATTERN_END
	LIM L, AUX2, `LL CHR_PATTERN_END
	LIM H, AUX3, `LH CHR_COLOR			; Pointer to chr color pallete offset
	LIM L, AUX3, `LL CHR_COLOR

	MOVE W, AUX0, R0	;WE WILL KEEP POINTER TO CHR_ROM IN R0 FOR NOW
	MOVE W, AUX1, R1	;POINTER TO CHR_PATTERN IN R1
	MOVE W, AUX2, R2	;POINTER TO CHR_PATTERN END IN R2
	MOVE W, AUX3, R3	;POINTER TO CHR_COLOR IN R3

	LIM H, AUX1, $0F
	LIM L, AUX1, $FF
	LIM H, AUX2, `LH CHR_BG_COLOR
	LIM L, AUX2, `LL CHR_BG_COLOR
	LIM W, AUX3, $00

	MOVE W, AUX1, R4	;POINTER TO CHR_ROM END IN R4
	MOVE W, AUX2, R5	;POINTER TO CHR_BG_COLOR IN R5
	MOVE W, AUX3, R6	;KEEP A ZERO HANDY IN R6

	;GET CHR COLOR IN R3
	MOVE W, R6, DAH
	MOVE W, R3, DAL
	MOVE W, DD, R3

	;GET BG COLOR IN R5
	MOVE W, R5, DAL
	MOVE W, DD, R5

BCP_LOOP
	;READ CHR WORD
	MOVE W, R6, DAH
	MOVE W, R0, DAL
	MOVE W, DD, R7	;PUT CHR WORD IN R7

	MOVE W, R6, R9	;CLEAR R9

	;GET BIT 7 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_70
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_70
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 6 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_60
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_60
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 5 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_50
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_50
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 4 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_40
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_40
	;COPY NIBBLE TO R9, THIS IS THE LAST NIBBLE SO WE DON'T ROTATE
	OR W, R9, R9	;OR AUX0 WITH R9

	;WRITE THE PATTERN WORD TO MEMORY
	MOVE W, R6, DAH
	MOVE W, R1, DAL
	LIM W, AUX0, $01
	MOVE W, R9, DD
	ADD W, R1, R1	;INCREMENT POINTER TO CHR_PATTERN

	MOVE W, R6, R9	;CLEAR R9

	;GET BIT 3 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_30
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_30
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 2 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_20
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_20
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 1 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_10
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_10
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 0 OF LINE 0
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_00
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_00
	;COPY NIBBLE TO R9, THIS IS THE LAST NIBBLE SO WE DON'T ROTATE
	OR W, R9, R9	;OR AUX0 WITH R9

	;WRITE THE PATTERN WORD TO MEMORY
	MOVE W, R6, DAH
	MOVE W, R1, DAL
	LIM W, AUX0, $01
	MOVE W, R9, DD
	ADD W, R1, R1	;INCREMENT POINTER TO CHR_PATTERN

	MOVE W, R6, R9	;CLEAR R9

	;GET BIT 7 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_71
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_71
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 6 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_61
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_61
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 5 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_51
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_51
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 4 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_41
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_41
	;COPY NIBBLE TO R9, THIS IS THE LAST NIBBLE SO WE DON'T ROTATE
	OR W, R9, R9	;OR AUX0 WITH R9

	;WRITE THE PATTERN WORD TO MEMORY
	MOVE W, R6, DAH
	MOVE W, R1, DAL
	LIM W, AUX0, $01
	MOVE W, R9, DD
	ADD W, R1, R1	;INCREMENT POINTER TO CHR_PATTERN

	MOVE W, R6, R9	;CLEAR R9

	;GET BIT 3 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_31
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_31
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 2 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_21
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_21
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 1 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_11
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_11
	;COPY NIBBLE TO R9, THEN ROTATE LEFT
	OR W, R9, R9	;OR AUX0 WITH R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9
	ROL W, R9, R9

	;GET BIT 0 OF LINE 1
	LIM W, AUX0, $01
	ROL W, R7, R7
	AND W, R7, R8	;PUT THE BIT IN R8

	;DECIDE WHICH COLOR TO USE
	BRNZ BCP_FG_01
	MOVE W, R3, AUX0	;DUE TO DELAYED BRANCHING THIS INSTRUCTION IS NEVER SKIPPED
	MOVE W, R5, AUX0	;GET THE SELECTED COLOR IN LOWER NIBBLE OF AUX0
BCP_FG_01
	;COPY NIBBLE TO R9, THIS IS THE LAST NIBBLE SO WE DON'T ROTATE
	OR W, R9, R9	;OR AUX0 WITH R9

	;WRITE THE PATTERN WORD TO MEMORY
	MOVE W, R6, DAH
	MOVE W, R1, DAL
	LIM W, AUX0, $01
	MOVE W, R9, DD
	ADD W, R1, R1	;INCREMENT POINTER TO CHR_PATTERN

	;CHECK IF WE ARE DONE AND INCREMENT CHR_ROM POINTER
	MOVE W, R0, AUX0
	XOR W, R4, AUX1	;COMPARE CHR_ROM POINTER TO CHR_ROM_END POINTER
	LIM W, AUX0, $01
	BRNZ BCP_LOOP
	ADD W, R0, R0	;INCREMENT CHR_ROM POINTER

	RET
	NOP


COPY_PATTERN_TO_MEM
	;CHR_PATTERN
	LIM H, AUX1, `LH CHR_PATTERN
	LIM L, AUX1, `LL CHR_PATTERN
	LIM H, AUX2, `LH CHR_PATTERN_END
	LIM L, AUX2, `LL CHR_PATTERN_END

	MOVE W, AUX1, R1	;POINTER TO CHR_PATTERN IN R1
	MOVE W, AUX2, R2	;POINTER TO CHR_PATTERN END IN R2

	LIM H, AUX1, `LH XGRI_PAR
	LIM L, AUX1, `LL XGRI_PAR
	MOVE W, AUX1, IAL			; Set I/O addr to addr of PAR
	LIM W, AUX0, $00
	MOVE W, AUX0, ID			; Fill PAR w/ 0
	MOVE W, AUX0, DAH			; Zero DAH

CPTM_LOOP
	LIM H, AUX1, `LH XGRI_STATUS	
	LIM L, AUX1, `LL XGRI_STATUS
	MOVE W, AUX1, IAL			; Set I/O addr to addr of XGRI Status register
	BITT L, ID, 2				; Status[2] (p_empty) -> Z Reg
	BRZ CPTM_LOOP
	NOP

	LIM H, AUX1, `LH XGRI_PDR	
	LIM L, AUX1, `LL XGRI_PDR
	MOVE W, AUX1, IAL			; Set I/O addr to addr of PDR
	LIM W, AUX0, $01			; Save a '1'

	; 0
	MOVE W, R1, DAL				; Set DAL to "address of current pattern in CHR_PATTERN"
	MOVE W, DD, ID				; Move pattern from CHR_PATTERN to PDR (PAR=n --> PAR=n+1)
	ADD W, R1, R1				; Increment "address of current pattern" 

	; 1
	MOVE W, R1, DAL				; Set DAL to "address of current pattern in CHR_PATTERN"
	MOVE W, DD, ID				; Move pattern from CHR_PATTERN to PDR (PAR=n+1 --> PAR = n+2)
	ADD W, R1, R1				; Increment "address of current pattern"

	; 2
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 3
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 4
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 5
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 6
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 7
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 8
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 9
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 10
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 11
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 12
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 13
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 14
	MOVE W, R1, DAL				
	MOVE W, DD, ID				
	ADD W, R1, R1				

	; 15
	MOVE W, R1, DAL				
	MOVE W, DD, ID			

	;CHECK IF WE ARE DONE AND INCREMENT CHR_PATTERN POINTER
	MOVE W, R1, AUX0
	XOR W, R2, AUX1	;COMPARE CHR_PATTERN POINTER TO CHR_PATTERN_END POINTER
	LIM W, AUX0, $01
	BRNZ CPTM_LOOP
	ADD W, R1, R1	;INCREMENT CHR_PATTERN POINTER

	RET
	NOP

DIV16
; R2 = R0 / R1
; R3 USED AS INDEX
	TEST W, R1
	BRNZ DIV16_NZ
	LIM W, AUX0, $00
	RET
	NOP
DIV16_NZ
	LIM W, AUX1, $01
	MOVE W, AUX0, R2	;CLEAR RESULT
	MOVE W, AUX1, R3	;SET INDEX TO 1
SHIFT_IT16
	BITT W, R1, 15
	BRNZ DIV16_LOOP	;IF MSB OF DENOMINATOR IS SET GOTO DIV16_LOOP
	NOP
	ROL W, R1, R1
	BRA SHIFT_IT16
	ROL W, R3, R3	;SHIFT LEFT DENOMINATOR AND INDEX
DIV16_LOOP
	MOVE W, R1, AUX0
	SUB W, R0, AUX3	;SUBTRACT DENOMINATOR FROM NUMERATOR
	BRN FINAL16	;IF THE RESULT IS NEGATIVE GOTO FINAL16
	MOVE W, R3, AUX0	;PUT INDEX IN AUX0
	MOVE W, AUX3, R1	;MAKE THE SUBTRACTION RESULT THE NEW DENOMINATOR
	ADD W, R2, R2	;ADD INDEX TO THE RESULT
FINAL16
	LIM H, AUX0, $7F
	LIM L, AUX0, $FF
	ROR W, R3, R3
	ROR W, R1, R1
	AND W, R3, R3	;SHIFT RIGHT INDEX
	BRNZ DIV16_LOOP
	AND W, R1, R1	;SHIFT RIGHT DENOMINATOR
	RET
	NOP

MUL16
; R2 = R0 * R1
	LIM W, AUX3, $00
	MOVE W, AUX3, R2	;CLEAR RESULT
MACC16
; R2 = R0 * R1 + R2
	BITT W, R0, 0
	BRZ MACC16_SHIFT	;IF LSB OF R0 IS CLEARED SKIP ADDING
	MOVE W, R1, AUX0
MACC16_ADD
	ADD W, R2, R2	;ADD R1 TO THE RESULT
MACC16_SHIFT
	LIM W, AUX0, $FE
	ROL W, R1, R1
	AND W, R0, R0
	ROR W, R0, R0	;SHIFT RIGHT R0
	BRNZ MACC16
	AND W, R1, R1	;SHIFT LEFT R1
	RET
	NOP

	ORG $0C00	;PLACE CHR ROM
INCLUDE "NF_CHR.INC"
